<!--
    Here you'll find the main exhibit: the chat application code. Feel free to look around!
-->
{% extends 'base.jinja' %}

{% block content %} 
<style>

    body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        background-color: #f4f4f4;
    }

    .main {
        display: flex;
        justify-content: space-between;
        margin: 20px;
    }

    .Chat {
        flex: 4; /* Takes up 3/4 of the space */
        margin-right: 20px;
        background-color: #fff;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0px 0px 5px 0px rgba(0,0,0,0.15);
    }

    .Friends {
        flex: 1; /* Takes up 1/4 of the space */
        background-color: #fff;
        padding: 20px;
        margin-right: 20px;
        border-radius: 10px;
        box-shadow: 0px 0px 5px 0px rgba(0,0,0,0.15);
    }

    .Incoming_Friends_Request {
        flex: 1; /* Takes up 1/4 of the space */
        background-color: #fff;
        padding: 20px;
        margin-right: 20px;
        border-radius: 10px;
        box-shadow: 0px 0px 5px 0px rgba(0,0,0,0.15);
    }

    .Outgoing_Friends_Request {
        flex: 1; /* Takes up 1/4 of the space */
        background-color: #fff;
        padding: 20px;
        margin-right: 20px;
        border-radius: 10px;
        box-shadow: 0px 0px 5px 0px rgba(0,0,0,0.15);
    }

    #message_box {
        border: 1px solid #ddd;
        height: 400px;
        width: 100%;
        overflow: auto;
        padding: 10px;
        margin-bottom: 20px;
        border-radius: 5px;
    }

    .text {
        margin: 5px 0;
    }

    nav {
        display: flex;
        justify-content: flex-end;
        background-color: #333;
        color: #fff;
        padding: 0.2em 1em;
        font-size: 1.5em;
    }

    button {
        background-color: #f44336;
        border: none;
        color: white;
        padding: 10px 10px;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 16px;
        cursor: pointer;
        border-radius: 4px;
    }

    button:hover {
        background-color: #d32f2f;
        color: #fff;
    }

    .receiver {
        font-size: 16px;
        padding: 10px;
    }

    h1 {
        text-align: left;
        padding-left: 20px;
        color: blue;
        margin: 20px 0;
    }

    nav ol li {
        display: inline-block;
        margin-right: 20px;
    }

    .Friends_button {
        background: #333;
        color : white;
        margin: 10px 0;
    }

    .button-container {
        display: block;
        margin: 10px 0;
    }

</style>

<!--Navbar, you'll see the username here-->
<nav>
    <ol>
        <li><b>Username:</b>  {{ username }} </li>
        <li><button onclick="(async () => { await logout(); })()">Logout</button></li>
    </ol>
</nav>

<h1>Messaging App </h1>
<main class="main">


    <div class="Chat">
        <h3><div id="chatting_to">Chatting to: No one at the moment !</div></h3>
        <!-- The messages are displayed here -->
        <section id="message_box"></section>

        <!-- The (message) input box is set to display: none initially,
        this means the input box is "invisible" initially-->
        <section id="input_box" style="display: none" >
            <p class="text">Message: </p>
            <input class="receiver" id="message" placeholder="message" oninput="checkInput()">
            <button id="sendButton" onclick="send()" disabled>Send</button>
            <button onclick="leave()">Leave Room</button>
        </section>

        <style>
            button:disabled {
                background-color: #cccccc;
                color: #666666;
            }
        </style>

    </div>

    <div class="Incoming_Friends_Request">
        <h2>Friend Requests</h2>

    </div>

    <div class="Outgoing_Friends_Request">
        <h2>Friend Requests Sent</h2>

    </div>

    <div class="Friends">
        <h2>Friends List</h2>

    </div>

</main>

<script src="/static/js/libs/jschmac.bundle.js"></script>
<script src="/static/js/libs/socket.io.min.js"></script>
<script>



    let init_room_id = 0;

    let room_id = 0;

    let glob_conversation = "";

    let current_receiver = "";

    let is_talking = false;





    // when the user presses the "Enter" key inside of the "message box",
    // the message is sent to the server
    $("#message").on("keyup", (e) => {
        if (e.key == "Enter") {
            send();
        }
    })

    // when the user presses the enter key inside of the "receiver box"
    // the user joins a (socket) room
     $("#receiver").on("keyup", (e) => {
        if (e.key == "Enter") {
            join_room();
        }
    })

    $(document).ready(() => {
        // Call checkInput initially to set the correct state of the "Send" button
        checkInput();

        // Call checkInput whenever the value of the input box changes
        $("#message").on("input change paste", checkInput);
        // ...
    });

    // Here's the Socket IO part of the code
    // things get a bit complicated here so brace yourselves :P
    let username = "{{ username }}";

    Cookies.set('username', username);

    // initializes the socket
    const socket = io();

    //unlocks the send button when the input box is filled with text
    function checkInput() {
        var message = document.getElementById('message').value;
        if (message.trim() != '') {
            document.getElementById('sendButton').disabled = false;
        } else {
            document.getElementById('sendButton').disabled = true;
        }
    }

    socket.on('update', function(data) {
        // Assuming you have functions to update HTML with new data
        updateFriendsList(data.friends);
        updateOutgoingRequests(data.outgoing);
        updateIncomingRequests(data.incoming);
    });

    // an incoming message arrives, we'll add the message to the message box
    socket.on("incoming", async (user1, encryptedMsg, mac) => {  // Mark this function as async
        if (user1 == username) {   // Ensure the message is meant for this user
            try {
                const decryptedMessage = await decryptMessage(encryptedMsg);    //Decrypts the message using the user's private key
                if (typeof decryptedMessage === "string" && decryptedMessage.trim() !== "") {   //ensuring the string is in the right format
                    let mac_bytes = base64ToUint8Array(mac);

                    let status = await verify_hmac(decryptedMessage, mac_bytes); // Await HMAC verification
                    console.log(decryptedMessage)
                    //Only add the message if the MAC verification passes
                    if (status) {
                        await add_conversation(decryptedMessage);
                        await add_message_sys(decryptedMessage);
                    } else {
                        console.log("MAC verification failed.");
                    }
                }
            } catch (error) {
                console.error("Decryption failed:", error); // Handle decryption errors
                await add_message_sys(`${user1}: [Message could not be decrypted]`);
            }
        }
    });

    socket.on("init_room_id", async (init_id) => {

        room_id = init_id;
        init_room_id = init_id;
        console.log(init_room_id);
        Cookies.set("room_id", init_id);
    })

    socket.on("incoming_sys_init", async (encrypted_msg, macbase, room_id, color="black") => {
        
        if (!encrypted_msg) {
            Cookies.set("room_id", room_id);
            return;
        }

        const encrypted_convo = encrypted_msg.split("+++").filter(msg => msg.trim() !== "");  // Split and filter out empty results
        const decrypted_msgs = [];

        //decrypting conversation messages
        for (let msg of encrypted_convo) {
            if (msg) {  // Check if the message is not undefined or empty
                const decrypted = await decryptMessage(msg);
                if (decrypted) {
                    if (decrypted.trim() !== "" && decrypted.trim() != "\n") {  // Ensure the decrypted message isn't empty or just whitespace
                        decrypted_msgs.push(decrypted);  // Add it to the array
                    }
                }

            }
        }

        //joins the decrypted messages into one string
        let decrypted_convo = '';
        if (decrypted_msgs.length > 0) {
            decrypted_convo = decrypted_msgs.join("");
        }
        //conversation history is added to the global conversation
        add_convo_init(decrypted_convo);
        console.log(decrypted_convo);
        let mac_bytes = base64ToUint8Array(macbase);
        let status = await verify_hmac(decrypted_convo, mac_bytes);

        if (status) {
            await add_message_sys(decrypted_convo);
        }
        else {
            console.log("Mac verification failed.");
        }
        Cookies.set("room_id", room_id);

    });

    socket.on("incoming_sys_disconnect", () => {
            console.log("bro has disconnected");
            Cookies.set("room_id", room_id);
            leave();
            console.error("Your friend has disconnected.");
        })


    window.addEventListener("beforeunload", async function (event) {
        socket.emit("user_disconnect", username, room_id);
        await leave();
        Cookies.remove("room_id");
    });



    async function encryptMessage(publicKey, message) {
        const encrypted = await cryptico.encrypt(message, publicKey);
        return encrypted;  // Return Base64-encoded encrypted message
    }

    async function decryptMessage(encryptedMessage) {
        const passphrase = await getData();
        const serial_privkey = await getRSAKey(passphrase);
        const privateKey = importRSAKey(serial_privkey);



        if (!encryptedMessage) {
            console.log('Encrypted message is undefined or null');
            throw new Error('Encrypted message is undefined or null');
        }



        let decrypted;
        try {
            decrypted = await cryptico.decrypt(encryptedMessage, privateKey);
        } catch (e) {
            console.log('Error decrypting message:', e);
            throw new Error('Failed to decrypt message. Ensure the private key matches the public key used for encryption.');
        }
        
        console.log(decrypted);
        console.log(decrypted.plaintext);

        if(decrypted.plaintext != undefined && decrypted.plaintext != ""){
            return decrypted.plaintext;
        }
    }

    async function fetchUserid(user) {
        try {
            const response = await fetch(`/api/users/${user}/get_user_id`, {
                method: "GET"
            });
            /*if (!response.ok) {
                throw new Error(`Failed to fetch public key for user: ${receiver}`);
            }*/
            const data = await response.json();
            console.log(data);
            return data.user_id;  // Assuming the backend sends the public key in this field
        } catch (error) {
            console.error("Fetching user id failed:", error);
        }
    }

    async function fetchPublicKey(receiver) {
        try {
            const response = await fetch(`/api/users/${receiver}/get_public_key`, {
                method: "GET"
            });
            const data = await response.json();
            return data.pubkey;  // Assuming the backend sends the public key in this field
        } catch (error) {
            console.error("Fetching public key failed:", error);
        }
    }

    function arrayBufferToBase64(buffer) {
        let binary = '';
        let bytes = new Uint8Array(buffer);
        let len = bytes.byteLength;
        for (let i = 0; i < len; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return window.btoa(binary);
    }

    function base64ToUint8Array(base64) {
        var binaryString = window.atob(base64); // Decode base64 to binary string
        var len = binaryString.length;
        var bytes = new Uint8Array(len); // Create a new Uint8Array with the same length as the binary string
        for (var i = 0; i < len; i++) {
            bytes[i] = binaryString.charCodeAt(i); // Convert each character to a byte
        }
        return bytes;
    }

    async function send() {
        let receiver = current_receiver;    //Gets the current receiver
        let message = $("#message").val();  // Get the message from the input box

        $("#message").val("");  // Clear the message input early for a better user experience
        checkInput();

        try {
            //grabs the receiver's public key
            const receiverPublicKey = await fetchPublicKey(receiver);

            if (!receiverPublicKey) {
                console.error("No public key found for receiver:", receiver);
                alert("Cannot find receiver's public key."); // Notifies the user if the public key is not found
                return;  // Exit the function if no public key was fetched
            }

            let formattedMessage = username + ": " + message;   //formats message to include the sender's name
            let mac = await generate_hmac(formattedMessage);  // Generate HMAC for the actual message to be sent
            let encryptedMessage = await encryptMessage(receiverPublicKey, formattedMessage);  // Encrypt the full formatted message
            let macbase = arrayBufferToBase64(mac);


            let current_room_id = Cookies.get("room_id");
            console.log(current_room_id);
            // Emit the message over the socket
            socket.emit("send", receiver, encryptedMessage.cipher, macbase, current_room_id);

            // Add the formatted message to the user's chat window locally for immediate feedback
            await add_message(formattedMessage)


        } catch (error) {
            console.error("Error in sending message:", error);
            alert("Failed to send the message."); // Provide feedback on failure
        }
    }

    // Function to encode strings to Uint8Array
    function encodeString(input) {
        const encoder = new TextEncoder();
        return encoder.encode(input);
    }

    // Function to generate HMAC
    async function generate_hmac(message) {
        const receiver = current_receiver;
        const user_id = await fetchUserid(username);
        const receiver_id = await fetchUserid(receiver);
        const key = `${Math.max(user_id, receiver_id)}${Math.min(user_id, receiver_id)}`;
        const encodedKey = encodeString(key);
        const encodedMessage = encodeString(message);

        // Assume HMAC key needs to be 32 bytes; adjust or pad as needed
        const hmacKey = new Uint8Array(32);
        hmacKey.set(encodedKey.slice(0, 32));

        // Compute HMAC
        return window.jschmac.compute(hmacKey, encodedMessage, "SHA-256");
    }

    // Function to verify HMAC
    async function verify_hmac(message, mac) {
        const receiver = current_receiver;
        const user_id = await fetchUserid(username);
        const receiver_id = await fetchUserid(receiver);
        const key = `${Math.max(user_id, receiver_id)}${Math.min(user_id, receiver_id)}`;
        const encodedKey = encodeString(key);
        const encodedMessage = encodeString(message);

        // Assume HMAC key needs to be 32 bytes; adjust or pad as needed
        const hmacKey = new Uint8Array(32);
        hmacKey.set(encodedKey.slice(0, 32));

        // Verify HMAC
        return window.jschmac.verify(hmacKey, encodedMessage, mac, "SHA-256");
    }

    function open_chat(friend) {
        leave();
        join_room(friend);
    }

    // we emit a join room event to the server to join a room
    function join_room(friend) {
        console.log("Joining room with: " + friend);
        current_receiver = friend;  //sets receiver to the friend you clicked on
        //pass in the receiver of our message to the server as well as the current user's username
        socket.emit("join", username, current_receiver, (res) => {

            // returns an error message if the server returns an error
            if (typeof res != "number") {
                alert(res);
                return;
            }

            // set the room id variable to the room id returned by the server
            room_id = res;
            Cookies.set("room_id", room_id);

            // now we'll show the input box, so the user can input their message
            document.getElementById("chatting_to").innerHTML = "Chatting to: " + friend;    //updates the chatting to box
            $("#input_box").show();
        });

    }

    // function when the user clicks on "Leave Room"
    // emits a "leave" event, telling the server that we want to leave the room
    function leave() {
        Cookies.remove("room_id");
        Cookies.set("room_id", init_room_id);
        clear_convo();
        socket.emit("leave", username, init_room_id);
        document.getElementById("chatting_to").innerHTML = "Chatting to: No one at the moment !";
        $("#input_box").hide();
        $("#message_box").empty();
    }

    // function to add a message to the message box
    // called when an incoming message has rea
    // ched a client

    async function add_message_sys(message, color) {
        let box = $("#message_box");
        // Replace newline characters with <br> tags
        message = message.replace(/\n/g, '<br>');
        // Use .html() instead of .text() to interpret the <br> tags
        let child = $(`<p style="color:${color}; margin: 0px;"></p>`).html(message);
        box.append(child);
    }

    async function add_message(message, color) {
        let box = $("#message_box");
        // Replace newline characters with <br> tags
        await add_conversation(message); //appends to global conversation variable
        await send_conversation(message);   //sends the encrypted message to the server
        let formatted_message=message.replace(/\n/g, '<br>');
        // Use .html() instead of .text() to interpret the <br> tags
        let child = $(`<p style="color:${color}; margin: 0px;"></p>`).html(formatted_message);
        box.append(child);  //adds the message to the box

        
    }

    function add_convo_init(message){
        if (message != "" && message != "\n" && message != undefined) {
            glob_conversation += message;
        }
    }

    async function add_conversation(message) {
        if (message != "" && message != "\n" && message != undefined) {
            glob_conversation += (message + "\n");
        }
    }

    function clear_convo() {
        glob_conversation = "";
    }

    async function send_conversation(conversation) {
        let sender = current_receiver   //Gets the current receiver
        conversation += "\n";   //Adds a newline character to the end of the message
        const username_id = await fetchUserid(username);    //Fetches the user id of the current user
        const sender_id = await fetchUserid(sender);    //Fetches the user id of the sender

        //determines which user is user1 and which is user2
        var user1;
        var user2;
        if(username_id && sender_id) {
            if (username_id > sender_id) {
                user1 = username;
                user2 = sender;
            }
            else {
                user1 = sender;
                user2 = username;
            }
        }

        //grabs public keys of user to encrypt
        const pubkey1 = await fetchPublicKey(user1);
        const pubkey2 = await fetchPublicKey(user2);

        let encrypted_conversation1 = "";
        let encrypted_conversation2 = "";

        let mac = await generate_hmac(glob_conversation);  // Generate HMAC for the entirety of the conversation history
        let macbase = arrayBufferToBase64(mac);

        //creates two encrypted messages, one for each user
        encrypted_conversation1 = cryptico.encrypt(conversation, pubkey1);
        encrypted_conversation2 = cryptico.encrypt(conversation, pubkey2);
        encrypted_conversation1 = encrypted_conversation1.cipher;
        encrypted_conversation2 = encrypted_conversation2.cipher;

        //sends the encrypted conversations to the server
        socket.emit("send_convo", encrypted_conversation1, encrypted_conversation2, macbase, username, sender);
    }

    // Logout function
    async function logout() {
        // Redirect to the logout rout
        socket.emit("user_disconnect", username, room_id, function(response) {
            if (response) {
                window.location.href = "/logout";
            }
        });
    }


    async function add_friend_request() {
        let friend = prompt("Enter the name of the friend you want to add:");
        friend = encodeURI(friend);
        try {
            friend_id = await fetchUserid(friend);
            user_id = await fetchUserid(username);
        } catch(error) {
            console.error("Error in fetching user id:", error);
        }
        if (user_id) {
            socket.emit("add_friend_request", user_id, friend_id);
        }

    }

    function add_friend(friend) {
        socket.emit("add_friend", username, friend);
    }

    function remove_request(friend) {
        socket.emit("remove_request", username, friend);
    }

    function reject_request(friend) {
        socket.emit("reject_request", username, friend);
    }

    function updateIncomingRequests(requests) {
        const container = document.querySelector('.Incoming_Friends_Request');
        container.innerHTML = '<h2>Friend Requests</h2>';  // Clear content and add header
        if (!requests.length) {
            container.innerHTML += '<p>No friend requests yet!</p>';
        } else {
            requests.forEach(request => {
                container.innerHTML += `<div class="button-container">
                    <button class="Friends_button">${request}</button> <button onclick="add_friend('${request}')">Accept</button>
                    <button onclick="reject_request('${request}')">Decline</button>
                </div>`;
            });
        }
    }

    function updateOutgoingRequests(requests) {
        const container = document.querySelector('.Outgoing_Friends_Request');
        container.innerHTML = '<h2>Friend Requests Sent</h2>';  // Clear content and add header
        if (!requests.length) {
            container.innerHTML += '<p>No friend requests sent!</p>';
        } else {
            requests.forEach(request => {
                container.innerHTML += `<div class="button-container">
                    <button class="Friends_button">${request}</button>
                    <button class="Friends_button" onclick="remove_request('${request}')">Cancel Request</button>
                </div>`;
            });
        }
    }

    function updateFriendsList(friends) {
        const container = document.querySelector('.Friends');
        container.innerHTML = '<h2>Friends List</h2>';  // Clear content and add header
        if (!friends.length) {
            container.innerHTML += '<p>No friends yet!</p>';
        } else {
            friends.forEach(friend => {
                container.innerHTML += `<div class="button-container">
                    <button onclick="open_chat('${friend}')" class="Friends_button">${friend}</button>
                    <button class="Friends_button" onclick="remove_friend('${friend}')">Remove</button>
                </div>`;
            });
        }
        container.innerHTML += '<button onclick="add_friend_request()">Add Friend</button>';
    }

    function remove_friend(friend) {
        socket.emit("remove_friend", username, friend);
    }
</script>
{% endblock %}